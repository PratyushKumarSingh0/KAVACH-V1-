import os
import hashlib
import psutil
import threading
import json
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import logging

class AdvancedMalwareDetector:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.malware_signatures = self.load_malware_signatures()
        self.ransomware_indicators = [
            '.encrypted', '.locked', '.crypto', '.ransom', '.wncry', '.cryptolocked'
        ]
        self.suspicious_process_names = [
            'cryptolocker', 'wannacry', 'petya', 'badrabbit', 'locky', 'cerber'
        ]
        self.file_monitor = FileMonitor(self.logger)
        self.monitoring = False
        
    def load_malware_signatures(self):
        """Load known malware signatures"""
        try:
            with open('data/threat_signatures.json', 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Error loading malware signatures: {e}")
            return {}
    
    def calculate_file_hash(self, file_path):
        """Calculate SHA256 hash of file"""
        try:
            hasher = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hasher.update(chunk)
            return hasher.hexdigest()
        except Exception as e:
            self.logger.error(f"Error calculating file hash: {e}")
            return None
    
    def detect_malware_by_hash(self, file_path):
        """Signature-based malware detection"""
        file_hash = self.calculate_file_hash(file_path)
        if file_hash and file_hash in self.malware_signatures:
            malware_type = self.malware_signatures[file_hash]
            self.logger.warning(f"Malware detected by signature: {malware_type} - {file_path}")
            return malware_type
        return None
    
    def detect_ransomware_behavior(self, file_path):
        """Behavior-based ransomware detection"""
        try:
            filename = file_path.lower()
            
            # Check for ransomware file extensions
            for indicator in self.ransomware_indicators:
                if indicator in filename:
                    return "RANSOMWARE"
            
            # Check for rapid file modifications
            if self.is_rapid_encryption(file_path):
                return "RANSOMWARE_ENCRYPTION"
            
            # Check file size anomalies
            if self.is_file_size_suspicious(file_path):
                return "SUSPICIOUS_FILE_OPERATION"
                
        except Exception as e:
            self.logger.error(f"Ransomware detection error: {e}")
            
        return None
    
    def is_rapid_encryption(self, file_path):
        """Detect rapid file encryption patterns"""
        try:
            file_size = os.path.getsize(file_path)
            if file_size == 0:
                return True
                
            # Check file modification frequency (simplified)
            return False
            
        except Exception as e:
            return False
    
    def is_file_size_suspicious(self, file_path):
        """Detect suspicious file size changes"""
        try:
            # This would normally track file size history
            # For now, just check for very large or very small files
            size = os.path.getsize(file_path)
            return size > 100 * 1024 * 1024 or (size < 100 and size > 0)  # >100MB or <100B but not empty
        except:
            return False
    
    def scan_running_processes(self):
        """Scan for suspicious processes"""
        suspicious = []
        
        for process in psutil.process_iter(['pid', 'name', 'memory_info', 'cpu_percent']):
            try:
                process_name = process.info['name'].lower() if process.info['name'] else ''
                
                # Check against known malicious process names
                for suspicious_name in self.suspicious_process_names:
                    if suspicious_name in process_name:
                        suspicious.append({
                            'pid': process.info['pid'],
                            'name': process.info['name'],
                            'type': 'KNOWN_MALWARE_PROCESS',
                            'confidence': 'HIGH'
                        })
                
                # Check for unusual memory usage
                if process.info['memory_info']:
                    memory_mb = process.info['memory_info'].rss / 1024 / 1024
                    if memory_mb > 500:  # Processes using >500MB RAM
                        suspicious.append({
                            'pid': process.info['pid'],
                            'name': process.info['name'],
                            'memory_mb': memory_mb,
                            'type': 'HIGH_MEMORY_USAGE',
                            'confidence': 'MEDIUM'
                        })
                
                # Check for high CPU usage
                if process.info['cpu_percent'] and process.info['cpu_percent'] > 50:
                    suspicious.append({
                        'pid': process.info['pid'],
                        'name': process.info['name'],
                        'cpu_percent': process.info['cpu_percent'],
                        'type': 'HIGH_CPU_USAGE',
                        'confidence': 'MEDIUM'
                    })
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        return suspicious
    
    def monitor_file_system(self):
        """Start real-time file system monitoring"""
        if not self.monitoring:
            self.file_monitor.start()
            self.monitoring = True
    
    def stop_monitoring(self):
        """Stop file system monitoring"""
        if self.monitoring:
            self.file_monitor.stop()
            self.monitoring = False

class FileMonitor(FileSystemEventHandler):
    def __init__(self, logger):
        self.observer = Observer()
        self.suspicious_activities = []
        self.logger = logger
        
    def on_modified(self, event):
        if not event.is_directory:
            self.analyze_file_change(event.src_path)
    
    def on_created(self, event):
        if not event.is_directory:
            self.analyze_file_change(event.src_path)
    
    def analyze_file_change(self, file_path):
        """Analyze file changes for malicious activity"""
        try:
            detector = AdvancedMalwareDetector()
            
            # Check for ransomware indicators
            ransomware_type = detector.detect_ransomware_behavior(file_path)
            if ransomware_type:
                self.suspicious_activities.append({
                    'file': file_path,
                    'type': ransomware_type,
                    'action': 'BLOCK_AND_ALERT'
                })
                self.logger.warning(f"Ransomware activity detected: {file_path} - Type: {ransomware_type}")
            # Check for known malware
            malware_type = detector.detect_malware_by_hash(file_path)
            if malware_type:
                self.suspicious_activities.append({
                    'file': file_path,
                    'type': malware_type,
                    'action': 'QUARANTINE'
                })
                self.logger.warning(f"Malware detected: {file_path} - Type: {malware_type}")
                
        except Exception as e:
            self.logger.error(f"File analysis error: {e}")
    
    def start(self):
        """Start monitoring"""
        try:
            # Monitor user directories (adjust paths as needed)
            paths_to_monitor = [
                os.path.expanduser('~/Documents'),
                os.path.expanduser('~/Downloads'),
                os.path.expanduser('~/Desktop')
            ]
            
            for path in paths_to_monitor:
                if os.path.exists(path):
                    self.observer.schedule(self, path, recursive=True)
            
            self.observer.start()
            self.logger.info("File system monitoring started")
        except Exception as e:
            self.logger.error(f"Failed to start file monitoring: {e}")
    
    def stop(self):
        """Stop monitoring"""
        try:
            self.observer.stop()
            self.observer.join()
            self.logger.info("File system monitoring stopped")
        except Exception as e:
            self.logger.error(f"Error stopping file monitor: {e}")